import numpy as np

##Notes for drawing von neumann neighboorhoods

# What we need to know
# center point with variable length
# store points of a given dimension
# store a point's previous direction vector
#     Maybe that's already stored in the coordinate?
#     0 -> can become -1 or +1
#     -1 can only become -2
#     1 can only become 2


# Rules for each tick:
#     Each previous point moves in each possible direction once
#     Possible moves are +1, -1 in only ONE axis
#     0 -> can become -1 or +1
#     -1 can only become -2
#     1 can only become 2
#     Higher dimensions are invisible to lower dimensions
#         E.g. 1,1,1 is virtually 1,1 in 2D and the 2D operation does not work with the 3d axis
#      Higher dimensions moves are impossible from coords that have already moved in a lower dimension
#       0,1,0,3 prohibited from moving to 0,1,1,3 or 0,1,0,4


#Observation:
#This is a recursive problem:
#In 1D we draw a line
#In 2D we draw a line, from each 2D coordinate we draw a line
#In 3D we draw a line, from each 3D coordinate we draw two lines, from which we draw more lines
#In 4D we draw a line, from each 4D coordinate we draw three lines, from which we draw more lines

#Strategy:
#For R=1 -> Simply +1 -1 on each dimension axis,
# thereby generating 2 new coordinates per dimension axis
#Keep new coords in separate collections depending on dimension (important later)
#For R>1 
# General rules
# #1 Each dimension draws it's own (straight) line
# #2 Each dimension draws junction coordinates to the lower dimension
# #3 Each dimension uses only previous R value coordinates
# #4 Each dimension uses only coordinates from it's own dimension collection
# #5 Moving away from 0 in an axis restricts to only moving in the same direction on the axis
# #6 Moving in a lower dimension restricts moves to only the lower dimension or lower
#  EG. We have 3d coord (0,0,3) -> it moves in 2d (0,1,3) Now it can never move in 3D again
#          0,1,3 -> 0,1,4 is an invalid move (0,2,3),(1,1,3),(-1,1,3) are it's valid moves
#   (The rule that slipped away from me)
# Pragmatic rules
# #0 Init with 0,0,0... D for center and init for R=1
# #1 On each increase of R Take the previous coordinates
#   (for the corresponding dimension)
# #2 Iterate through the sub-coordinate for each axis
#   (ignoring all higher dimension axis)
# #3 If axis coord = 0 -> change the axis coord to -1 and 1, generating two new coordinates
# #4 If axis coord != 0 -> Increment axis value by absolute 1 (-1 -> -2, 1 -> 2)
# #5 If axis coord != 0 -> Ignore any higher axis (break)
# -> These rules seem to generate Von Neumann shape without repetition


    
    
# dimensions = 3
# width = 9
# data = np.zeros(tuple(width for _ in range(dimensions)), dtype=int)

# from data import random_fill

# random_fill(3, data)
# # print(data)

# n = get_neuman_neighbors([4,4,4], data, 3, dimensions)
# print(len(n))
# print(n)

# print(data)
# z = 0
# for i in (1,3,5,7,5,3,1):
#     j = i
#     while j:
#         j-=1
#         print(n[z], end=" ")
#         z+=1
#     print("\n")